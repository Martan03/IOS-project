#!/bin/bash

echo "Zakomentovat před odevzdáním!!!!"
MOLE_RC="/home/martan03/Documents/IOS/Projekt1/molerc"
EDITOR="vim"

POSIXLY_CORRECT=yes

# Shows help
function show_help() {
    echo "Welcome to MOLE by xsleza26!"
    echo "Usage:"
    echo "  mole -h"
    echo "    Displays help"
    echo "  mole [-g GROUP] FILE"
    echo "    Opens file, file opening will be assigned to the group if given"
    echo "  mole [-m] [FILTERS] [DIRECTORY]"
    echo "    Opens file from given directory (or current directory)"
    echo "    If no filters, last edited file will be opened"
    echo "  mole list [FILTERS] [DIRECTORY]"
    echo "    Lists files that were opened/edited with MOLE"
    echo "  mole secret-log [-b DATE] [-a DATE] [DIRECTORY1 [DIRECTORY2] [...]]"
    echo "    Displays a secret log"
    echo ""
    echo "FILTERS:"
    echo "  [-g GROUP1[,GROUP2][,...]"
    echo "     Group specification"
    echo "  [-a DATE]"
    echo "    Records of the opened/edited files after this date"
    echo "  [-b DATE]"
    echo "    Records of the opened/edited files before this date"
    echo "  DATE"
    echo "    In format YYYY-MM-DD"
}

# Prints given message to stderr
function echo_err() {
    1>&2 echo $1
}

# Shows invalid usage message
function show_invalid() {
    echo_err "Invalid usage. Type: 'mole -h' to show help"
}

# Gets default editor
# If EDITOR is set, it is used; else VISUAL; else vi
function get_editor() {
    editor="${EDITOR:-${VISUAL:-vi}}"
}

# Escapes given string
function escape() {
    sed -e 's|\\|\\\\|g' -e 's|/|\\/|g' -e 's|*|\\*|g' -e 's|\.|\\\.|g' \
        -e 's|\[|\\\[|g' -e 's|\]|\\\]|g' -e 's|\^|\\\^|g' -e 's|\$|\\\$|g' \
        -e 's|(|\\(|g' -e 's|)|\\)|g'
}

# Checks if given date is valid and parses it to seconds
function valid_date() {
    if [ -z $1 ]
    then
        echo ""
        return
    elif [[ ! $1 =~ [0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9] ]]
    then
        echo_err <<< "Invalid date format: $1 (YYYY-MM-DD)"
        exit 1
    fi

    date -d $1 +%s 2> /dev/null
    if [ ! $? -eq 0 ]
    then
        echo_err "Invalid date: $1 (YYYY-MM-DD)"
        exit 1
    fi
}

# Saves usage to file given by MOLE_RC variable
function save_usage() {
    # Escapes path and group
    path="$(escape <<< $1)"
    grp="$(escape <<< "${2:+,$2,}")"
    
    # If file is not in MOLE_RC yet, save it
    if [ $(grep -c "^$path" $MOLE_RC) -eq 0 ]
    then
        echo "$1;$(date +"%s")-${2:+,$2,}" >> $MOLE_RC
        return
    fi

    # If file is already assigned to group, ignore group
    if [ $(grep -c "^$path.*$grp" $MOLE_RC) -gt 0 ]
    then
        grp=""
    fi

    # Edit file info in MOLE_RC
    sed -ri "s/($path;[^-]*)-(.*)/\1,$(date +"%s")-\2$grp/g" $MOLE_RC
}

# Opens file with text editor
function open_file() {
    if [ -z $1 ]
    then
        return 1
    fi

    save_usage $1 $2

    get_editor
    $editor $1
    return $?
}

# Opens last edited file meeting filters in given folder
# With -m flag opens most edited file meeting filters
function open_dir() {
    if [ ! -d $(realpath -m ${1:-.}) ]
    then
        echo_err "Error - file doesn't exist: $1"
        exit 1
    fi
    echo "Open dir not implemented"
    return 0
}

# Create file in given directory
function create_file() {
    if [ -z $1 ]
    then
        return 1
    elif [ -f "$(realpath $1)" ]
    then
        return 0
    fi

    mkdir -p "$(realpath -m "$(dirname "$1")")"
    touch "$(realpath "$1")"

    return 0
}

# Lists all the files in MOLE_RC meeting the filters
function list_file() {
    # Escapes path and group (default path value is '.')
    path="$(escape <<< $(realpath "${1:-.}"))"
    group="$(escape <<< $2)"

    # Regex each line into 3 groups (filename, dates, groups)
    # Checks if file meets the filters and prints it
    gawk '
        BEGIN {
            len = 1;
            longest = 1;
        }
        match($0, /('$path'\/[^;\/]*);([^-]*)-,(.*'$group'.*)$/, a) {
            path[len] = a[1];
            if (length(path[len]) > longest)
                longest = length(path[len]);
            time[len] = a[2];
            grp[len++] = a[3];
        }
        END {
            for (i = 1; i < len; i++)
            {
                n = split(time[i], times, ",");
                if (("'$a'" >= times[n]) && ("'$a'" != ""))
                    continue;
                if (("'$b'" <= times[1]) && ("'$b'" != ""))
                    continue

                printf "%s: ", path[i];
                for (j = 0; j < longest - length(path[i]); j++)
                    printf " ";

                split(substr(grp[i], 1, length(grp[i]) - 1), grps, ",");
                n = asort(grps)
                if (!n)
                    printf "-"
                for (j = 1; j < n; j++)
                    printf "%s,", grps[j];
                printf "%s\n", grps[n];
            }
        }' $MOLE_RC | sort
}

function create_log() {
    return 0
}

# Uses getopts to parse flags
function parse_flags() {
    while getopts :g:ma:b: OPTION
    do
        case "${OPTION}" in
            g)
                g=$OPTARG
                ;;
            m)
                m=0
                ;;
            a)
                a="$(valid_date $OPTARG)"
                ;;
            b)
                b="$(valid_date $OPTARG)"
                ;;
            *)
                show_invalid
                exit 2
                ;;
        esac
    done
}

# Checks if MOLE_RC var is set
if [ -z $MOLE_RC ]
then
    echo "Variable MOLE_RC is not set."
    exit 1
fi
# Create if it doesn't exist
create_file $MOLE_RC

case "$1" in
    list)
        shift
        parse_flags $*

        ((OPTIND--))
        shift $OPTIND

        list_file "$1" "$g" "$a" "$b"
        exit 0;
        ;;
    secret-log)
        shift
        echo "You found my epic secret log"
        exit 0;
        ;;
    -h)
        show_help
        exit 0
        ;;
    *)
        parse_flags $*
esac

((OPTIND--))
shift $OPTIND

# if $1 is empty, set value to '.' (current directory)
path="${1:-.}"

# mole [-m] [FILTERS] [DIRECTORY]
# Opens last edited with mole, corresponding to filters
# if m flag is set, opens most edited file
if [ -d "$(realpath "$path")" ]
then
    open_dir "$(realpath "$path")"
    exit $?
fi

if [ ! -z $m ] || [ ! -z $a ] || [ ! -z $b ]
then
    show_invalid
    exit 1
fi

# mole [-g GROUP] FILE
# Opens file, optional GROUP flag for opening to be assigned to
open_file "$(realpath "$path")" "$g"
exit $?
