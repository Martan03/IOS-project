#!/bin/bash

echo "Zakomentovat před odevzdáním!!!!"
MOLE_RC="/home/martan03/Documents/IOS/Projekt1/molerc"
EDITOR="vim"

POSIXLY_CORRECT=yes
LOG="${HOME}/.mole"

# Shows help
function show_help() {
    echo "Welcome to MOLE by xsleza26!"
    echo "Usage:"
    echo "  mole -h"
    echo "    Displays help"
    echo "  mole [-g GROUP] FILE"
    echo "    Opens file, file opening will be assigned to the group if given"
    echo "  mole [-m] [FILTERS] [DIRECTORY]"
    echo "    Opens file from given directory (or current directory)"
    echo "    If no filters, last edited file will be opened"
    echo "  mole list [FILTERS] [DIRECTORY]"
    echo "    Lists files that were opened/edited with MOLE"
    echo "  mole secret-log [-b DATE] [-a DATE] [DIRECTORY1 [DIRECTORY2] [...]]"
    echo "    Displays a secret log"
    echo ""
    echo "FILTERS:"
    echo "  [-g GROUP1[,GROUP2][,...]"
    echo "     Group specification"
    echo "  [-a DATE]"
    echo "    Records of the opened/edited files after this date"
    echo "  [-b DATE]"
    echo "    Records of the opened/edited files before this date"
    echo "  DATE"
    echo "    In format YYYY-MM-DD"
}

# Prints given message to stderr
function echo_err() {
    1>&2 echo $1
}

# Shows invalid usage message
function show_invalid() {
    echo_err "Invalid usage. Type: 'mole -h' to show help"
}

# Gets default editor
# If EDITOR is set, it is used; else VISUAL; else vi
function get_editor() {
    editor="${EDITOR:-${VISUAL:-vi}}"
}

# Escapes given string
function escape() {
    sed -e 's|\\|\\\\|g' -e 's|/|\\/|g' -e 's|*|\\*|g' -e 's|\.|\\\.|g' \
        -e 's|\[|\\\[|g' -e 's|\]|\\\]|g' -e 's|\^|\\\^|g' -e 's|\$|\\\$|g' \
        -e 's|(|\\(|g' -e 's|)|\\)|g'
}

# Gets files that were edited matching given filters
# $1 - g, $2 - a, $3 - b
function edited_filtered() {
    awk 'BEGIN {
        m = split("'$1'", grps, ",");
    }
    match($0, /^(.*);([^-]*)-,(.*)$/, a) {
        n = split(a[2], dates, ",");
        if (("'$2'" < dates[n] || "'$2'" == "") && 
            ("'$3'" > dates[1] || "'$3'" == "")) {
            a[3] = substr(a[3], 1, length(a[3]) - 1)
            for (i = 1; i <= m; i++) {
                c = split(a[3], g, ",");
                for (j = 1; j <= c; j++) {
                    if (g[j] == grps[i]) {
                        printf "%s;%s-,%s,\n", a[1], a[2], a[3];
                        i = m + 1;
                        break;
                    }
                }
            }
            if (m == 0)
                printf "%s;%s-,%s,\n", a[1], a[2], a[3];
        }
    }' $MOLE_RC
}

# Gets files that exist
function edited_exist() {
    awk 'match($0, /^(.*);([^-]*)-(.*)$/, a) {
        if (!system("test -f " a[1]))
            printf "%s;%s-%s\n", a[1], a[2], a[3];
    }'
}

# Gets last edited file
function last_edited() {
    awk 'match($0, /^(.*);([^-]*)-.*$/, a) {
        n = split(a[2], dates, ",");
        printf "%s %s", dates[n], a[1];
    }' | sort | tail -n 1 | sed -r 's/.* (.*)$/\1/'
}

# Gets most edited file
function most_edited() {
    awk 'match($0, /^(.*);([^-]*)-,.*$/, a) {
        printf "%d %s\n", split(a[2], date, ","), a[1];
    }' $MOLE_RC | sort | tail -n 1 | sed  -r 's/[0-9][0-9]* (.*)$/\1/'
}

# Checks if given date is valid and parses it to seconds
function valid_date() {
    if [ -z $1 ]
    then
        echo ""
        return
    elif [[ ! $1 =~ [0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9] ]]
    then
        echo_err <<< "Invalid date format: $1 (YYYY-MM-DD)"
        exit 1
    fi

    date -d $1 +%s 2> /dev/null
    if [ ! $? -eq 0 ]
    then
        echo_err "Invalid date: $1 (YYYY-MM-DD)"
        exit 1
    fi
}

# Saves usage to file given by MOLE_RC variable
function save_usage() {
    # Escapes path and group
    path="$(escape <<< $1)"
    grp="$(escape <<< "${2:+,$2,}")"
    
    # If file is not in MOLE_RC yet, save it
    if [ $(grep -c "^$path" $MOLE_RC) -eq 0 ]
    then
        echo "$1;$(date +"%s")-${2:+,$2,}" >> $MOLE_RC
        return
    fi

    # If file is already assigned to group, ignore group
    if [ $(grep -c "^$path.*$grp" $MOLE_RC) -gt 0 ]
    then
        grp=""
    fi

    # Edit file info in MOLE_RC
    sed -ri "s/($path;[^-]*)-(.*)/\1,$(date +"%s")-\2$grp/g" $MOLE_RC
}

# Opens file with text editor
function open_file() {
    echo "$1"
    if [ -z $1 ]
    then
        echo_err "Error openning file"
        return 1
    fi
    save_usage $1 $2

    get_editor
    $editor $1
    return $?
}

# Opens last edited file meeting filters in given folder
# With -m flag opens most edited file meeting filters
function open_dir() {
    if [ ! -d $(realpath -m ${1:-.}) ]
    then
        echo_err "Error - file doesn't exist: $1"
        exit 1
    fi
    
    if [ $m -eq 0 ]
    then
        open_file "$(edited_filtered "$2" "$3" "$4" | \
            edited_exist | most_edited)" ""
    else
        edited_filtered "$2" "$3" "$4"
        open_file "$(edited_filtered "$2" "$3" "$4" | \
            edited_exist | last_edited)" ""
    fi
}

# Create file in given directory
function create_file() {
    if [ -z $1 ]
    then
        return 1
    elif [ -f "$(realpath -m $1)" ]
    then
        return 0
    fi

    mkdir -p "$(realpath -m "$(dirname "$1")")"
    touch "$(realpath -m "$1")"

    return 0
}

# Lists all the files in MOLE_RC meeting the filters
function list_file() {
    # Escapes path
    path="$(escape <<< $(realpath "${1:-.}"))"

    edited_filtered "$2" "$3" "$4" | gawk '
        BEGIN {
            len = 1;
            longest = 1;
        }
        match($0, /^('$path'\/[^;\/]*);([^-]*)-,(.*)$/, a) {
            path[len] = a[1];
            if (length(path[len]) > longest)
                longest = length(path[len]);
            grp[len++] = a[3];
        }
        END {
            for (i = 1; i < len; i++)
            {
                printf "%s: ", path[i];
                for (j = 0; j < longest - length(path[i]); j++)
                    printf " ";

                split(substr(grp[i], 1, length(grp[i]) - 1), grps, ",");
                n = asort(grps)
                if (!n)
                    printf "-"
                for (j = 1; j < n; j++)
                    printf "%s,", grps[j];
                printf "%s\n", grps[n];
            }
        }' | sort
}

function edited_log() {
    awk 'match($0, /^(.*);([^-]*)-.*$/, a) {
        n = split(a[2], dates, ",");
        printf "%s", a[1];
        for (i = 1; i <= n; i++)
            printf ";%s", dates[i];
        printf "\n";
    }'
}

function create_log() {
    log="${LOG}/log_${USER}_$(date +"%F_%H-%M-%S").bz2"
    #create_file "$log"
    files="$(edited_filtered "" "$1" "$2" | edited_exist | edited_log)"
    if [ -z "${3+x}" ]
    then
        echo "$files" | sort | bzip2 -c > "$log" 
        return
    fi
    shift 2
    res=""
    for i do
        path="$(echo "$i" | escape)"
        res+="$(echo "$files" | \
        awk '/^('$path'\/[^;\/]*);.*$/ {
            print $0;
        }')"$'\n'
    done
    echo "$res" | sed -r '/^\s*$/d' | sort | bzip2 -c > "$log"
}

# Uses getopts to parse flags
function parse_flags() {
    m=1
    while getopts :g:ma:b: OPTION
    do
        case "${OPTION}" in
            g)
                g=$OPTARG
                ;;
            m)
                m=0
                ;;
            a)
                a="$(valid_date $OPTARG)"
                ;;
            b)
                b="$(valid_date $OPTARG)"
                ;;
            *)
                show_invalid
                exit 2
                ;;
        esac
    done
}

# Checks if MOLE_RC var is set
if [ -z $MOLE_RC ]
then
    echo "Variable MOLE_RC is not set."
    exit 1
fi
# Create if it doesn't exist
create_file $MOLE_RC

case "$1" in
    list)
        shift
        parse_flags $*

        ((OPTIND--))
        shift $OPTIND

        list_file "$1" "$g" "$a" "$b"
        exit 0;
        ;;
    secret-log)
        shift
        echo "You found my epic secret log"
        exit 0;
        ;;
    -h)
        show_help
        exit 0
        ;;
    *)
        parse_flags $*
esac

((OPTIND--))
shift $OPTIND

# if $1 is empty, set value to '.' (current directory)
path="${1:-.}"

# mole [-m] [FILTERS] [DIRECTORY]
# Opens last edited with mole, corresponding to filters
# if m flag is set, opens most edited file
if [ -d "$(realpath "$path")" ]
then
    open_dir "$(realpath "$path")"
    exit $?
fi

if [ ! -z $m ] || [ ! -z $a ] || [ ! -z $b ]
then
    show_invalid
    exit 1
fi

# mole [-g GROUP] FILE
# Opens file, optional GROUP flag for opening to be assigned to
open_file "$(realpath "$path")" "$g"
exit $?
